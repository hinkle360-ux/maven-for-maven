{"id": "coding_patterns:pattern:service_api_structure", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "Service API Structure Pattern", "description": "Standard structure for brain service APIs. Accept msg dict with 'op' and 'payload', return dict with 'ok' and 'payload' or 'error'. This pattern ensures consistent communication across all brains.", "examples": ["def service_api(msg: Dict[str, Any]) -> Dict[str, Any]:\n    op = msg.get('op')\n    payload = msg.get('payload', {})\n    if op == 'OPERATION':\n        result = process(payload)\n        return {'ok': True, 'payload': result}\n    return {'ok': False, 'error': 'unknown_op'}"], "tags": ["api", "structure", "deterministic", "brain_service"], "related_ids": ["governance_rules:rule:service_api_contract"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
{"id": "coding_patterns:pattern:service_api_error_handling", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "Service API Error Handling", "description": "Deterministic error handling using try-except blocks with specific exception types and explicit error messages. Always return structured error responses.", "examples": ["try:\n    result = operation()\n    return {'ok': True, 'payload': result}\nexcept ValueError as e:\n    return {'ok': False, 'error': f'invalid_value: {str(e)}'}\nexcept Exception as e:\n    return {'ok': False, 'error': f'unexpected: {str(e)}'}"], "tags": ["error_handling", "python", "deterministic", "api"], "related_ids": ["governance_rules:rule:explicit_errors"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
{"id": "coding_patterns:pattern:deterministic_dict_iteration", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "Deterministic Dictionary Iteration", "description": "When iterating over dictionaries where order matters, use sorted() to ensure deterministic behavior. This is critical for reproducible outputs.", "examples": ["# Deterministic iteration\nfor key in sorted(my_dict.keys()):\n    value = my_dict[key]\n    process(key, value)", "# Deterministic JSON output\nimport json\njson_str = json.dumps(data, sort_keys=True)"], "tags": ["determinism", "iteration", "python", "dictionaries"], "related_ids": ["governance_rules:principle:deterministic_storage"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
{"id": "coding_patterns:pattern:type_annotations", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "Type Annotations Pattern", "description": "Use type annotations for all function signatures. This improves code clarity, enables static type checking, and makes contracts explicit.", "examples": ["def process_message(msg: Dict[str, Any], context: Optional[Dict] = None) -> Dict[str, Any]:\n    pass", "from typing import Dict, Any, List, Optional"], "tags": ["types", "python", "clarity", "maintainability"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
{"id": "coding_patterns:pattern:jsonl_file_format", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "JSONL File Format Pattern", "description": "Use JSONL (JSON Lines) format for storing lists of structured data. One JSON object per line, no commas between lines. This enables streaming and deterministic storage.", "examples": ["# Writing JSONL\nwith open('data.jsonl', 'w') as f:\n    for item in sorted_items:\n        json_line = json.dumps(item, sort_keys=True)\n        f.write(json_line + '\\n')", "# Reading JSONL\nwith open('data.jsonl', 'r') as f:\n    for line in f:\n        item = json.loads(line.strip())\n        process(item)"], "tags": ["storage", "jsonl", "deterministic", "format"], "related_ids": ["governance_rules:principle:deterministic_storage"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
{"id": "coding_patterns:pattern:path_handling", "bank": "coding_patterns", "kind": "pattern", "content": {"title": "Path Handling with Pathlib", "description": "Use pathlib.Path for all file path operations. It's cross-platform, cleaner than os.path, and more Pythonic.", "examples": ["from pathlib import Path\n\nbase_dir = Path(__file__).parent\ndata_file = base_dir / 'data' / 'seeds.jsonl'\n\nif data_file.exists():\n    with open(data_file, 'r') as f:\n        data = f.read()"], "tags": ["paths", "pathlib", "python", "filesystem"]}, "tier": "ltm", "confidence": 1.0, "source": "seed", "deterministic": true}
